#     if !defined (longitude_maximale)
#         define   longitude_maximale 9999
#     endif
#     if !defined (latitude_maximale)
#         define   latitude_maximale 4999
#     endif
#     if defined (AUTO_DOC)
*
*     CALL SEQUENCE...
*      windowf  GIN GOUT INPUT OUTPUT [ -dlon1 VAL0 -dlon2 VAL1 
*                                       -dlat1 VAL2 -dlat2 VAL3 -npg VAL4 
*                                       -kind  VAL5 -nhem  VAL6 -a   VAL7 ]
*
*     DESCRIPTION...
*      windowf - PHYSICALLY EXTRAC OR EXPAND ONE WINDOW INTO ANOTHER
*
*
*     AUTHORS  - R.Laprise AND B.Dugas, JAN 21/87.
*     LAST REVISION: $Header: /home/cvs/RMNLIB/utils/rdiag/lspgm/windowf.ptn,v 4.26 2014/09/25 20:20:56 dugas Exp $
*
*
*     PURPOSE...
*      THIS PROGRAM WILL EITHER : 
* 
*      1) EXTRACT WINDOWS OF GRID FILE GIN  AND PUT THEM IN FILE
*         GOUT. I1, I2 AND J1, J2 ARE THE LEFT, RIGHT AND LOWER,
*         UPPER GRID INDICES OF THE WINDOW. 
* 
*                          ****  OR  ****
* 
*      2) EXPAND A  PRE-EXISTING WINDOW. POINTS OUTSIDE IT  ARE SET
*         TO A INPUT  DETERMINED VALUE.  (I1, J1) IS THE LEFT LOWER
*         CORNER THE WINDOW WILL OCCUPY IN GOUT AND (I2, J2) IS THE
*         ROW AND COLUMN DIMENSIONS OF GOUT.
*
*      NOTES: 1) IN BOTH CASES, THE SMALLER WINDOW MAY CROSS THE BORDER
*                OF THE LARGER (i.e. "I2 < I1" IN CASE(1)), AS LONG AS
*                WE DO NOT KNOW THAT THE LARGER IS NON-GLOBAL.
*             2) PARAMETERS I1 AND I2 ARE IGNORED FOR ZONAL ARRAYS.
*             3) FOR COMPLEX GRIDS, I1 AND I2 CORRESPOND TO COMPLEX NUMBERS.
*             4) APPROPRIATE GRID DESCRIPTORS FOR RPN STANDARD FILES ARE
*                WRITTEN. THIS MEANS THAT A GENERAL COMPRESSED SUB-GRID
*                MAY BE CONVERTED TO A 'Z' TYPE ARRAY. IN THIS CASE, THE
*                ORIGINAL DESCRIPTORS WILL BE RESTORED AT EXPANSION.
*
*
*     INPUT FILE...
*      GIN  = ANY FILE OF (REAL OR COMPLEX) GRIDS, SUBAREAS OR ZONAL ARRAYS
*
*     OUTPUT FILE...
*      GOUT = RESULTING FILE OF RESIZED ARRAYS
*
*
*     INPUT PARAMETER...
*
*      I1,   J1        AS DESCRIBED ABOVE. BOTH DEFAULT TO 1.
*     (dlon1,dlat1)    
*      I2,   J2        AS DESCRIBED ABOVE. DEFAULT TO WORD 5 AND 6
*     (dlon2,dlat2)    OF THE FIRST VALID DATA INFO BUFFER OF FILE GIN.
*                      THIS CORRESPONDS TO NI,NJ IN RPN STANDARD FILES.
*      TYPE  (kind)  = 0,         SHRINKING WINDOW CASE
*                      OTHERWISE, EXPANDING WINDOW CASE
*      VALUE (a)     = REAL NUMBER TO BE USED AS FILLING IN THE EXPANDING
*                      WINDOW CASE.
*      IHEM  (nhem)  = FORCE IHEM (HEMISPHERE ID) IN ALL OUTPUT GRID.
*      NPG           = (OPTIONAL ON COMMAND-LINE) OUTPUT PACKING DENSITY
*
*      READ( 5,5000 ) I1,I2, J1,J2, TYPE, VALUE, IHEM
*5000  FORMAT(10X,5I5,E10.0,I5)
*
*
*     EXAMPLE OF INPUT CARD...
*
* WINDOWF    10   20  128   64    1       0.0    0
*
*        0123456789012345678901234567890123456789012345678901234567890
*        1         2         3         4         5         6         7
*
*
*     EXIT CONDITIONS...
*       0 NO PROBLEMS
*       1 FOUND ARRAY NOT OF TYPE GRID,SUBA,CMPL OR ZONAL IN GIN
*       2 OUTPUT WINDOW SMALLER THAN INPUT IN EXPANDING CASE
*       3 MORE THAN ONE SIZE ARRAY IN GIN
*       4 INPUT PARAMETRE ERROR
*       5 ERROR READING GIN
*       6 ILLEGAL I1,I2 COMBINATION
*       7 ILLEGAL LAT-LON OUTPUT ARRAY
#     endif
#     if defined (RDIAG_LICENCE)
!---------------------------------- LICENCE BEGIN -------------------------------
! R.DIAG - Diagnostic tool kit for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This code is free software; you can redistribute it and/or modify it 
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------
#     endif
#     if !defined (NO_SOURCE)
      PROGRAM windowf
*    1        (      GIN,       GOUT,       INPUT,       OUTPUT,
*    2         TAPE1=GIN, TAPE2=GOUT, TAPE5=INPUT, TAPE6=OUTPUT)
  
*     $Log: windowf.ptn,v $
*     Revision 4.26  2014/09/25 20:20:56  dugas
*     Inserer le texte de la licence LPGPL 2.1 pour R.DIAG.
*
*     Revision 4.25  2013/11/05 20:00:08  dugas
*     Correction dans l'activation du mode I/O 64 bits.
*
*     Revision 4.24  2013/10/17 11:33:02  bernard
*      - Utiliser les macros longitude_maximale et latitude_maximale pour definir les
*        parametres MAXI et MAXJ, respectivement
*      - Utiliser ALLOCATE plutot que HPALLOC pour la gestion de la memoire de travail
*      - Declarations 'a la' F90
*
*     Revision 4.23  2012/11/29 23:27:19  dugas
*     Initialiser IP3=0 avant l'appel a ZIPIG.
*
*     Revision 4.22  2011/08/04 19:19:23  dugas
*     Corriger la valeur de IBUF(5) selon REPL avant ecriture des resultats.
*
*     Revision 4.21  2009/01/23 22:33:27  dugas
*     Ajouter la cle '-npg'.
*
*     Revision 4.20  2008/05/03 21:06:30  dugas
*     Modification generale pour r.gppf.
*
*     Revision 4.19  2007/12/20 21:17:51  dugas
*     Faire appel aux routines PRTLAB/PRTLAB2.
*
*     Revision 4.18  2007/08/29 16:14:17  dugas
*     Ajouter une verification pour PJC>360 pour les grilles L
*
*     Revision 4.17  2006/06/19 16:30:14  dugas
*     Corriger le calcul des >> et ^^ en mode expansion de grilles Z.
*
*     Revision 4.16  2005/07/05 18:51:33  dugas
*     Corriger les descripteurs lorsque la grille de sortie est en mode LAM.
*
*     Revision 4.15  2005/04/14 18:30:27  dugas
*     - Ignorer les enregistrements de type LABL/CHAR.
*     - Assurer une allocation minimale a la lecture de MAXW mots.
*
*     Revision 4.14  2004/11/12 17:59:58  dugas
*     - Pour des donnees d'entrees sur grillles de type A ou B,
*       les grilles de sortie sont maintenant de type L.
*     - Implementer la seconde version du support des grilles de type L.
*
*     Revision 4.13  2004/06/23 17:02:03  dugas
*     Conserver OKIND lorsque MAXW=0
*
*     Revision 4.12  2004/04/30 19:51:37  dugas
*     Ajouter code FLIP pour grille Z globale (v2)
*
*     Revision 4.11  2004/04/16 17:39:23  dugas
*     Ajouter code FLIP pour grille Z globale (v1)
*
*     Revision 4.10  2003/09/15 16:04:39  dugas
*     Corriger les definitions de VALX et VALY pour les sous-grilles de type Z
*
*     Revision 4.9  2003/08/25 20:11:31  dugas
*     Corriger l'appel a GETSET2 et le calcul a NR.
*
*     Revision 4.8  2003/07/04 01:15:43  dugas
*     Implanter SETRABT pour le traitement de RECABT.
*     Corriger le calcul de DXLA lorsque ILG est impair.
*
*     Revision 4.7  2002/12/06 16:05:24  dugas
*      Modifier le transfert de grilles Z vers des sous-grilles plus petites
*
*     Revision 4.6  2002/09/17 18:54:05  dugas
*     Conserver le type des enregistrements de renvois a la sortie.
*     Modifier le code de sortie d'erreur -3 (NLEV1 > NLEV).
*     Agrandir MAXJ de 999 a 1999.
*
*     Revision 4.5  2002/04/22 15:29:11  dugas
*     Modifier l'appel a PUTZREF
*
*     Revision 4.4  1999/11/17 18:58:30  armnrbd
*     Ajouter le traitement des descripteurs geographiques
*         pour les fichiers standards RPN.
*
*     Revision 4.3  1998/07/03 02:26:47  armnrbd
*     Allonger le format d'ecriture de la date sur le listing.
*
*     Revision 4.2  1997/09/26  17:39:31  armnrbd
*     Remplacer buf(16) par buf(taille_entete).
*
*     Revision 4.1  1996/11/12  19:41:23  armnrbd
*     Ajouter le support de grilles de type SUBA.
*
*     Revision 4.0  1994/11/17  14:22:41  armnrbd
*     Messages informatifs quand au passage de la version 3.x a 4.0...
*     1) Les espaces en debut des noms de variables de sont plus pertinents.
*     2) Les grilles complexes de type CMPL sont maintenant supportees.
*     3) Les fichiers SQI sont reconnus, lus et ecrit directements.
*     4) Plusieurs nouvelles cles sont disponibles au demarrage.
*
*     Revision 3.1  94/08/09  11:20:23  armnrbd
*     Implanter support de coupes zonales.
*     Implanter support de RPBLOC.
*     
*     Revision 3.0  93/10/13  13:57:27  armnrbd
*     Premiere version compatible HP-UX.
*     
*     Revision 1.4  92/11/30  10:48:49  armnrbd
*     Deuxieme iteration avec GETSIZ/GETSIZ2.
*     
*     Revision 1.3  92/04/27  10:22:06  armnrbd
*     Changement de nom: WINDOW --> WINDOWF.
*     
*     Revision 1.2  92/03/17  15:33:05  armnrbd
*     Ajouter "Header" dans documentation.
*     
*     Revision 1.1  92/03/16  10:15:09  armnrbd
*     Ajouter la documentation automatique.
*     
*     Revision 1.0  92/02/24  14:42:02  armnrbd
*     Initial revision
*     

***    JAN 21/87 - R.LAPRISE, B.DUGAS. 

***    HISTORIQUE DES MODIFICATIONS:  
***     -  LE 20 MAI 1989 (PAR B.DUGAS) ...
***        ...  UTILISER L'ALLOCATION DE MEMOIRE DYNAMIQUE.
***     -  LE 28 NOV 1990 (PAR B.DUGAS, RPN) ...
***        ...  VERSION CY920/IRIX F77.
***     -  LE 18 JAN 1991 (PAR B.DUGAS, RPN) ...
***        ...  AJOUTER UN APPEL A GETLIGN.
  
*-----------------------------------------------------------------
      IMPLICIT    none
  
      INTEGER, PARAMETER :: MAXI = longitude_maximale
      INTEGER, PARAMETER :: MAXJ = latitude_maximale
      INTEGER, PARAMETER :: MAXLEV= 999

      CHARACTER*2 OGRTYP,GRTYP,PKTYP
      LOGICAL     DONE1,DONE2,ROTATE
      CHARACTER*5 KIND,OKIND,ZTYP,LIGNE*80
      LOGICAL     OK,FLIP,FIRST,CMPL,LOCAL
      REAL        DXLA,DXLA2,DYLA,DYLA2,DGRW,CAT,
     +            VALUE,ZERO,C,PIC,PJC,D60,
     +            VALX(MAXI),VALY(MAXJ),TEMP(MAXI),
     +            ZEX1,ZEY1,ZEX2,ZEY2,ZLON0,ZLAT0,
     +            EX1,EX2,EY,ANGLE,ZLON1,ZLAT1,
     +            ZLON2,ZLAT2,LASLON
      REAL*8      PICONV,PIS2,ROT(3,3),POS,
     +            CL(MAXJ),SL(MAXJ),WL(MAXJ),DZX,
     +            RADL(MAXJ),WOSSL(MAXJ),DIST
      INTEGER     HEAD,JBUF(taille_entete), FULLG,TYPE,WINDO, NFIL,
     +            I1,I2,J1,J2, IHEM, ILG,ILAT,LON,LON1,LON2,
     +            LAT,LAT1,LAT2, LH, LEN,NWDS,JPAK, LEV(MAXLEV),
     +            NLEV,NLEV1,I,J,L,MAXW,NR,LENIN,LENOUT,
     +            IER,IO,OLON,OLAT,LATH,IG1,IG2,IG3,IG4,
     +            IP1,IP2,IP3, ZIG1,ZIG2,ZIG3,ZIG4,
     +            DIMX,DIMY,NIL,NIH,NJL,NJH,
     +            NILA,NJLA,REPL,NPG

      INTEGER, ALLOCATABLE, DIMENSION(:) :: IBUF
      real(8), ALLOCATABLE, DIMENSION(:) :: G,DAT

      POINTER   ( PG, C(2,1)   )
      POINTER   ( PD, CAT(2,1) )

      CHARACTER   NOMPRG*256
      COMMON     /PROGNAM/ NOMPRG

      LOGICAL, EXTERNAL :: RPBLOC,SETIO64
      INTEGER, EXTERNAL :: GETSIZ2,GETHIGH
      CHARACTER(4), EXTERNAL :: GETYP,GETHIC
      EXTERNAL    MACSPE,JCLPNT,GETLIGN,BURNF,XIT,
     +            SETLAB,LBLCHK,GETFLD2,PUTSET2,
     +            PUTHIGH,PUTHIC,GAUSSG,TRIGL2,PUTZREF,
     +            ZIPIG,CXGAIG,CIGAXG,GETZREF,
     +            GETZDES

      INTEGER     findlowcoreindex,findhighcoreindex
      EXTERNAL    findlowcoreindex,findhighcoreindex

      DATA        FLIP,FIRST,LOCAL / .FALSE.,.TRUE.,.TRUE. /
      DATA        DONE1,DONE2      / .FALSE.,.FALSE.       /
*=====================================================================

      NOMPRG =
     +'$Source: /home/cvs/RMNLIB/utils/rdiag/lspgm/windowf.ptn,v $'

*---------------------------------------------------------------------
***    ALLER CHERCHER QUELQUES CONSTANTES SPECIFIQUES.

      CALL MACSPE( HEAD,ZERO )
      CALL SETRABT( '&NON' )

      PIS2   = ASIN(1.D0)
      PICONV = 90. / PIS2

***    ACCEDER LES FICHIERS D'E/S.

      NFIL = 4
      CALL JCLPNT( NFIL, 1,2, 5,6 )

      NR = 0

***    SETUP FOR 64-BIT I/O.

      OK = SETIO64(.TRUE.)

      PKTYP = GETYP( 1 )

      NPG = 999

      IF (RPBLOC( ' ',LIGNE ))                                 THEN

***        CHECK PARAMETRE BLOCK.

          I1    = 0
          I2    = 0
          J1    = 0
          J2    = 0
          TYPE  = 0
          VALUE = 0.0
          IHEM  = 0

          OK = RPBLOC('DLAT1',LIGNE)
          IF (OK) READ(LIGNE,5,ERR=9000,END=9001,IOSTAT=IO) J1

          OK = RPBLOC('DLAT2',LIGNE)
          IF (OK) READ(LIGNE,5,ERR=9000,END=9001,IOSTAT=IO) J2

          OK = RPBLOC('DLON1',LIGNE)
          IF (OK) READ(LIGNE,5,ERR=9000,END=9001,IOSTAT=IO) I1

          OK = RPBLOC('DLON2',LIGNE)
          IF (OK) READ(LIGNE,5,ERR=9000,END=9001,IOSTAT=IO) I2

          OK = RPBLOC('KIND',LIGNE)
          IF (OK) READ(LIGNE,5,ERR=9000,END=9001,IOSTAT=IO) TYPE

          OK = RPBLOC('A',LIGNE)
          IF (OK) READ(LIGNE,10,ERR=9000,END=9001,IOSTAT=IO) VALUE

          OK = RPBLOC('NHEM',LIGNE)
          IF (OK) READ(LIGNE,5,ERR=9000,END=9001,IOSTAT=IO) IHEM

          OK = RPBLOC('NPG',LIGNE)
          IF (OK) READ(LIGNE,5,ERR=9000,END=9001,IOSTAT=IO) NPG

      ELSE

***    READ-IN POSITIONS AND SIZES AS  WELL AS THE TYPE  OF OPERATION
***    AND A POSSIBLE DEFAULT VALUE. IF TYPE IS FOUND TO BE ZERO, OP-
***    TION (1) DESCRIBED  EARLIER WILL  HOLD. TYPE NOT EQUAL TO ZERO
***    WILL MEAN YOU SELECTED OPTION (2). IHEM CAN ALSO BE SPECIFIED.
  
          CALL GETLIGN( 5,LIGNE,80,OK )

          IF (.NOT.OK)                                         THEN
              GOTO 9001
          ELSE
              READ( LIGNE, 5000,ERR=9000,END=9001,IOSTAT=IO) 
     +                     I1,I2, J1,J2, TYPE, VALUE, IHEM
              CALL BURNF
          END IF

      END IF

***    READ IN FIRST INFORMATION BUFFER.
  
  050 MAXW = GETSIZ2( 1, JBUF,LENIN,NWDS,JPAK, LEV,NLEV )
      IF (MAXW.EQ.0) GOTO 9002

      WRITE(KIND,4) JBUF(1)
      IF (NR.EQ.0) OKIND = KIND

      IF (FIRST)                                               THEN

***        DO THIS ONLY ONCE.

          FIRST = .FALSE.

***        WAS IHEM SPECIFIED?

          IF (IHEM.NE.JBUF(7))                                 THEN  
              IHEM = IABS(IHEM)
              WRITE(6,6120) IHEM,JBUF(7)
          END IF

          IF (KIND.EQ.'ZONL')                                  THEN

***            REPLACE I INDICES BY J INDICES.

              I1   = J1
              I2   = J2

***            DO NOT PERMIT ADDING OR REMOVING LEVELS.

              J1   = 1
              J2   = NLEV

          END IF

***        DO DEFAULTS HAVE TO BE INVOKED ?

          IF (I1.LE.0) I1 = 1
          IF (I2.LE.0) I2 = JBUF(5)
          IF (J1.LE.0) J1 = 1
          IF (J2.LE.0) J2 = JBUF(6)

          IF (TYPE.EQ.0)                                       THEN
              WRITE(6,6100) I1, J1, I2, J2
          ELSE
              WRITE(6,6110) I1, J1, I2, J2, VALUE
          END IF
  
      END IF

***    GRID/SUBA/ZONL/CMPL INPUT ?
  
      IF (KIND.NE.'GRID'  .AND.
     +    KIND.NE.'SUBA'  .AND.
     +    KIND.NE.'ZONL'  .AND.
     +    KIND.NE.'CMPL' ) CALL                    XIT(' Windowf',-1 )

                          CMPL = .FALSE.
      IF (KIND.EQ.'CMPL') CMPL = .TRUE.

***    CHECK COHERENCE IN OPTION (2) CASE.
  
      IF (TYPE.NE.0 .AND.
     +   (JBUF(5).GT.I2 .OR. JBUF(6)+J1-1.GT.J2))              THEN
          WRITE(6,6002) JBUF(5),JBUF(6),I1,J1,I2,J2
          CALL                                     XIT(' Windowf',-2 )
      END IF

***    SET-UP ARRAY BOUNDS.
  
      ILG  = JBUF(5)
      ILAT = JBUF(6)
  
      IF (TYPE.EQ.0)                                           THEN
          LON  = ILG
          LAT  = ILAT
          LON1 = MIN(LON, MAX(  1, I1)) 
          LON2 = MAX(  1, MIN(LON, I2)) 
          LAT1 = MIN(LAT, MAX(  1, J1)) 
          LAT2 = MAX(  1, MIN(LAT, J2)) 
          OLAT = LAT2-LAT1+1
          OLON = LON2-LON1+1
      ELSE
          LON  = I2 
          LAT  = J2 
          OLAT = LAT
          OLON = LON
          LON1 = MIN(LON, MAX( 1, I1))
          LAT1 = MIN(LAT, MAX( 1, J1))
          LON2 = MOD(LON1+ILG -2, LON) +1
          LAT2 =     LAT1+ILAT-1
      END IF
  
      IF (LON2.LT.LON1)                                        THEN
          FLIP = .TRUE.
          LH   = LON2
          LON2 = LON1
          LON1 = LH 
          IF (TYPE.EQ.0) OLON = LON-LON2+1 + LON1
      END IF
  
*---------------------------------------------------------------------
***    DETERMINE NECESSARY WORK ARRAY SIZES.

      CALL SETLAB( JBUF, ' ',-1,' ',-1, LON,LAT, -1,-1 ) 
      CALL LBLCHK( LENOUT, NWDS,JPAK, JBUF )

      LEN  = MAX( LENIN,LENOUT )
      MAXW = LEN-HEAD
  
      IF (KIND.EQ.'ZONL') NWDS = JBUF(5)

***    ASK FOR THE REQUIRED AMOUNT OF MEMORY ...

      ALLOCATE( IBUF(LEN),G(  MAX( MAXW,NLEV*NWDS )),
     +                    DAT(MAX( MAXW,NLEV*NWDS )),STAT=IER )

      PG = LOC( G(1) ) ! C shares the same memory as G
      PD = LOC( DAT(1) ) ! CAT shares the same memory as DAT
  
***    INITIALISE DAT/CAT TO DEFAULT VALUE IN CASE (2).
  
      IF (TYPE.NE.0)                                           THEN
          DO  I=1,NWDS*NLEV
              DAT(I) = VALUE
          END DO
      END IF

      REPL = 0

      IF (PKTYP == 'SQ' .AND. NR   == 0
     +                  .AND. ILG  >  2 
     +                  .AND. ILAT >  2)                       THEN

          GRTYP = GETHIC( 'GRTYP',JBUF )

          IG1   = GETHIGH( 'IG1' ,JBUF ) 
          IG2   = GETHIGH( 'IG2' ,JBUF ) 
          IG3   = GETHIGH( 'IG3' ,JBUF ) 
          IG4   = GETHIGH( 'IG4' ,JBUF ) 

***        INITIALIZE OUTPUT GRTYP.

          OGRTYP = GRTYP

          IF (GRTYP.EQ.'N' .OR.
     +        GRTYP.EQ.'S' )                                   THEN

***            POLAR-STEREOGRAPHIC INPUT/OUTPUT.

              CALL CIGAXG( GRTYP, PIC,PJC,D60,DGRW,
     +                            IG1,IG2,IG3,IG4 )
          
              IF (TYPE.EQ.0)                                   THEN
                  PIC = PIC - LON1 + 1
                  PJC = PJC - LAT1 + 1
              ELSE
                  PIC = PIC + LON1 - 1
                  PJC = PJC + LAT1 - 1
              END IF

              CALL CXGAIG( GRTYP, IG1,IG2,IG3,IG4, 
     +                            PIC,PJC,D60,DGRW )

          ELSE IF (GRTYP.EQ.'G' .OR.
     +             GRTYP.EQ.'A' .OR.
     +             GRTYP.EQ.'B')                               THEN

***            GAUSSIAN OR REGULAR LAT-LON INPUT.

              LATH = ILAT / 2 
              IF (IG1.NE.0) LATH = ILAT

              IF (GRTYP.EQ.'G')                                THEN

                  CALL GAUSSG( LATH, SL,WL,CL,RADL,WOSSL ) 
                  CALL TRIGL2( LATH, SL,WL,CL,RADL,WOSSL,IG1 )

              ELSE IF (GRTYP.EQ.'A')                           THEN

                  DYLA = PIS2/LATH

                  IF (IG1.EQ.1)                                THEN
                      RADL(1) = 0.5*DYLA
                  ELSE
                      RADL(1) = 0.5*DYLA-PIS2
                  END IF

                  DO  J=2,ILAT
                      RADL(J) = RADL(J-1)+DYLA
                  END DO

                  DXLA = 4*PIS2 / (ILG-MOD( ILG,2 ))

              ELSE IF (GRTYP.EQ.'B')                           THEN

                  IF (IG1.EQ.0)                                THEN
                      DYLA = 2.*PIS2/(ILAT-1)
                      RADL(1) = -PIS2
                  ELSE IF (IG1.EQ.1)                           THEN
                      DYLA = PIS2/(ILAT-1)
                      RADL(1) = 0.0
                  ELSE IF (IG1.EQ.2)                           THEN
                      DYLA = PIS2/(ILAT-1)
                      RADL(1) = -PIS2
                  END IF

                  DO  J=2,ILAT
                      RADL(J) = RADL(J-1)+DYLA
                  END DO

                  DXLA = 4*PIS2 / (ILG-1)

              END IF

              IF (IG2.EQ.1)                                    THEN

***                ACCOUNT FOR NORTH TO SOUTH GRID ORIENTATION.

                  DO  J=1,ILAT/2
                      DIST           = RADL(     J  )
                      RADL(     J  ) = RADL(ILAT-J+1)
                      RADL(ILAT-J+1) = DIST
                  END DO

              END IF

              IF (ILG.EQ.OLON .AND. 
     +       (OLAT.EQ.ILAT                                        .OR.
     +       (OLAT.EQ.LATH   .AND. (J1.EQ.1 .OR. J1.EQ.LATH+1))   .OR.
     +       (OLAT.EQ.2*ILAT .AND. (J1.EQ.1 .OR. J1.EQ.ILAT+1)))) THEN

***                OUTPUT IS STILL GAUSSIAN.

                  IF (OLAT.NE.ILAT)                            THEN
                      IF (PJC.EQ.0)                            THEN
                          IF (OLAT.EQ.LATH  .AND. J1.EQ.     1) PIC = 2
                          IF (OLAT.EQ.LATH  .AND. J1.EQ.LATH+1) PIC = 1
                      ELSE IF (PJC.EQ.1)                       THEN
                          IF (OLAT.EQ.LATH  .AND. J1.EQ.     1) PIC = 1
                          IF (OLAT.EQ.LATH  .AND. J1.EQ.LATH+1) PIC = 2
                      END IF
                      IF (OLAT.EQ.2*ILAT .AND. J1.EQ.     1) PIC = 0
                      IF (OLAT.EQ.2*ILAT .AND. J1.EQ.LAT +1) PIC = 0
                  END IF

              ELSE IF (GRTYP.EQ.'A' .OR. GRTYP.EQ.'B')         THEN
     +               

***                DEFINE OUTPUT AS A L-TYPE SUB-GRID.

                  OKIND  = 'SUBA'
                  OGRTYP = 'L'

                  D60    = DYLA*PICONV
                  DGRW   = DXLA*PICONV

                  IF (FLIP .AND. GRTYP.EQ.'B') REPL = 1

                  PIC  = RADL(LAT1) * PICONV
                  PJC  = (LON1 - 1) * DGRW
                  IF (FLIP)
     +            PJC  = (LON2 - 1) * DGRW

                  D60  = NINT( D60 *1000. )/1000.
                  DGRW = NINT( DGRW*1000. )/1000.
                  PIC  = NINT( PIC *1000. )/1000.
                  PJC  = NINT( PJC *1000. )/1000.

                  CALL CXGAIG( OGRTYP, IG1,IG2,IG3,IG4,
     +                                 PIC,PJC,D60,DGRW )
 
              ELSE

***                DEFINE OUTPUT AS A Z-GRID.

                  OKIND  = 'SUBA'
                  OGRTYP = 'Z'

                  DXLA = 360./(ILG-MOD( ILG,2 ))

***                DEFINE SPACING IN X-DIRECTION.

                  VALX(1) = (I1-1)*DXLA
                  DO  I=2,OLON
                      VALX(I) = VALX(I-1)+DXLA
                      IF (VALX(I).GT.360.)
     +                VALX(I) = VALX(I) - 360.
                  END DO

***                ENSURE MONOTONOUSLY INCREASING VALX.

                  IF (VALX(1).GT.VALX(OLON))                   THEN
                      DO  I=OLON-1,1,-1
                          VALX(I) = VALX(I+1)-DXLA
                      END DO
                  END IF

***                DEFINE SPACING IN Y-DIRECTION.

                  IF (TYPE.EQ.0)                               THEN
                      DO  J=1,OLAT
                          VALY(J) = PICONV * RADL(J+J1-1)
                      END DO
                      DYLA = (VALY(OLAT) - VALY(1)) / (OLAT - 1)
                  ELSE
                      DO  J=1,ILAT
                          VALY(J+J1-1) = PICONV * RADL(J)
                      END DO
                      DYLA = (VALY(ILAT+J1-1) - VALY(J1)) / (ILAT - 1)
                      DO  J=J1+ILAT,OLAT
                          VALY(J) = VALY(J-1) + DYLA
                          IF (VALY(J).GT.90.) CALL  XIT(' Windowf',-2 )
                      END DO
                      DO  J=J1-1,1,-1
                          VALY(J) = VALY(J+1) - DYLA
                          IF (VALY(J).GT.-90.) CALL XIT(' Windowf',-2 )
                      END DO
                  END IF

                  DYLA = ABS( DYLA )

                  IP3 = 0
                  CALL ZIPIG( IP1,IP2,IP3, DXLA,DYLA, OLON,
     +                        OLAT,OLON,OLAT,ROT,.FALSE. )

                  IF (VALX(1).LT.0.0)                          THEN
                      DO  I=1,OLON
                          VALX(I) = VALX(I)+180.
                      END DO
                      CALL CXGAIG( 'E', IG1, IG2,  IG3, IG4,
     +                                  0.0, 000., 0.0, 090. )
                  ELSE
                      CALL CXGAIG( 'E', IG1, IG2,  IG3, IG4,
     +                                  0.0, 180., 0.0, 270. )
                  END IF

                  CALL PUTZREF( VALX,VALY, 'Z',
     +                         'E',IG1,IG2,IG3,IG4,
     +                          IP1,IP2,IP3,OLON,OLAT )

                  IG1 = IP1 
                  IG2 = IP2
                  IG3 = IP3
                  IG4 = 0

                  IF (RADL(1).GT.RADL(ILAT))
     +            IG4 = 1

              END IF

          ELSE IF (GRTYP.EQ.'L')                               THEN

              CALL CIGAXG( GRTYP, PIC,PJC,D60,DGRW,
     +                            IG1,IG2,IG3,IG4 )

***            LAT-LON INPUT/OUTPUT.

              IF (FLIP)                                        THEN
                  IF (TYPE.EQ.0)                               THEN
                      PIC = PIC + (LAT1 - 1) * D60
                      PJC = PJC + (LON2 - 1) * DGRW
                  ELSE
                      PIC = PIC - (LAT1 - 1) * D60
                      PJC = PJC - (LON2 - 1) * DGRW
                  END IF
              ELSE
                  IF (TYPE.EQ.0)                               THEN
                      PIC = PIC + (LAT1 - 1) * D60
                      PJC = PJC + (LON1 - 1) * DGRW
                  ELSE
                      PIC = PIC - (LAT1 - 1) * D60
                      PJC = PJC - (LON1 - 1) * DGRW
                  END IF
              END IF

***            CHECK OUTPUT BOUNDS.

              LASLON = (OLON-1)*DGRW

              IF ( PJC          .LT.   0.0) PJC = PJC+360.
              IF ( PJC          .GE. 360.0) PJC = PJC-360.

              IF ( PIC          .LT. -90.0  .OR.
     +             LASLON       .GT.+360.0  .OR.
     +        PIC+(OLAT-1)*D60  .GT. +90.0) CALL   XIT(' Windowf',-7 )

              IF (FLIP                      .AND.
     +           (ABS(LASLON-360.).LT.0.01) .AND. 
     +           (ABS(PJC)        .LT.0.01)) REPL = 1

              CALL CXGAIG( GRTYP, IG1,IG2,IG3,IG4,
     +                            PIC,PJC,D60,DGRW )

          ELSE IF (GRTYP.EQ.'Z')                               THEN

***            Z-GRID INPUT.

              CALL GETZREF( 1, '>>',VALX )
              CALL GETZREF( 1, '^^',VALY )

***            RETREIVE/DECODE COORDINATE ROTATION INFORMATION.

              CALL GETZDES( ZTYP, ZIG1,ZIG2,ZIG3,ZIG4, DIMX,DIMY )

              CALL CIGAXG( ZTYP, ZLAT1,ZLON1, ZLAT2,ZLON2,
     +                           ZIG1,ZIG2,ZIG3,ZIG4 )

              IF (TYPE .EQ.0   .OR.
     +           (ZLAT1.NE.0.0 .OR. ZLAT2.NE.0.0))             THEN

***                OUTPUT IS STILL A Z-GRID BECAUSE A) WE ONLY
***                WANT A SUB-GRID, OR B) THE GRID IS ROTATED.

                  IF (TYPE.EQ.0)                               THEN

***                    SUB-GRID CASE.

                      DXLA = VALX(2)-VALX(1)
                      DO  I=3,DIMX
                          DXLA = MIN( DXLA, VALX(I)-VALX(I-1))
                      END DO

                      DYLA = VALY(2)-VALY(1)
                      DO  I=3,DIMY
                          DYLA = MIN( DYLA, VALY(I)-VALY(I-1))
                      END DO

                      IF (FLIP .AND.
     +                   (ABS( VALX(ILG)-VALX(1)-360. ).LT.
     +                        1.2*(VALX(2)-VALX(1))))          THEN  

                          LOCAL = .FALSE.

                          CALL ANGLEP12( ANGLE,ZLON1,ZLAT1,ZLON2,ZLAT2 )

***                        SHIFT THE EQUATOR TO ACCOUNT FOR THE FLIP.
***                        START BY FINDING THE CENTER ON THE NEW DOMAIN.

                          DZX = 0.5*((VALX(LON1)+360.)-VALX(LON2))
                          EX1 = VALX(LON2)+DZX

  100                     IF (EX1.LT.  0.) EX1 = EX1+360.
                          IF (EX1.GE.360.) EX1 = EX1-360.
                          EY = 0.0

                          CALL D_ROTA( ZEX1,ZEY1,EX1,EY,
     +                                 ZLON1,ZLAT1,ZLON2,ZLAT2,
     +                                 ZLON0,ZLAT0, 1,1 )

***                        ALSO DEFINE THE SECOND POINT ON THE EQUATOR TO
***                        BE ANGLE DEGREES AWAY FROM THE NEW FIRST POINT.

                          EX2 = MIN( EX1+ANGLE , 359.999 )

                          IF (EX2-EX1.LT.1.0) WRITE(6,6150)

                          CALL D_ROTA( ZEX2,ZEY2,EX2,EY,
     +                                 ZLON1,ZLAT1,ZLON2,ZLAT2,
     +                                 ZLON0,ZLAT0, 1,1 )

                          WRITE(6,6200) ZEY1,ZEX1,ZEY2,ZEX2

***                        DEFINE THE NEW CENTER OF THE GRID AND ITS
***                        STANDARD Z-GRID DESCRIPTORS (I.E. THE IGx).

                          CALL CXGAIG( ZTYP, ZIG1,ZIG2,ZIG3,ZIG4,
     +                                       ZEY1,ZEX1,ZEY2,ZEX2 )                          

                          EX1 = EX1-180.

C                         IF (EX1-ANGLE.GT.   0 .OR.
C    +                        EX1-ANGLE.LE.-180.)              THEN
C
C                             IF (.NOT.DONE1)                  THEN
C                                 DONE1 = .TRUE.
C                                 EX1  = VALX(LON1)-180.
C                                 GOTO 100
C                             ELSE IF (.NOT.DONE2)             THEN
C                                 DONE2 = .TRUE.
C                                 EX1  = VALX(LON2)+180.
C                                 GOTO 100
C                             END IF
C
***                            CAS OU IL FAUDRAIT CHANGER L'ORIENTATION
***                            DE LA GRILLE, C'EST A DIRE: 1) LAT = -LAT
***                            (SYMMETRIE P/R A L'EQUATEUR) ET ENFIN 2)
***                            LON = 180-LON (SYMMETRIE P/R 180). TOUT
***                            CECI N'A PAS ENCORE ETE FAIT, DONC...
C
C                             WRITE(6,6006)
C                             CALL                 XIT(' Windowf',-6 )
C
C                         END IF
                              
***                        SAVE THE NEW LONGITUDES (SHIFTED BY EX1)
***                        AND THE LATITUDE SUBSET.

                          DO  I=LON2,ILG
                              TEMP(I-LON2+1) = VALX(I)-EX1
                          END DO
                          DO  I=1,LON1
                              TEMP(I+ILG-LON2+1) = VALX(I)-EX1
                          END DO

                          IF (TEMP(1)   .EQ.360.) TEMP(1) = 0.
                          IF (TEMP(OLON).EQ.  0.) TEMP(1) = 360.

                          DO  I=1,OLON
                              IF (TEMP(I).LT.  0.) TEMP(I)=TEMP(I)+360.
                              IF (TEMP(I).GT.360.) TEMP(I)=TEMP(I)-360.
                              VALX(I) = TEMP(I)
                          END DO

***                        CHECK THAT THE GREENITCH MERIDIAN IS NOT REPEATED.

                          DO  I=2,OLON
                              IF (VALX(I).EQ.VALX(I-1))        THEN
                                  WRITE(6,6016) I-1,VALX(I)
                                  CALL             XIT(' Windowf',-6 )
                              END IF
                          END DO

                      ELSE IF (FLIP)                           THEN
                          WRITE(6,6006)
                          CALL                     XIT(' Windowf',-6 )
                      ELSE
                          DO  I=1,OLON
                              VALX(I) = VALX(I+I1-1)
                          END DO
                      END IF

                      DO  J=1,OLAT
                          VALY(J) = VALY(J+J1-1)
                      END DO

                      NIL = findlowcoreindex(  VALX,OLON )
                      NIH = findhighcoreindex( VALX,OLON )
                      NJL = findlowcoreindex(  VALY,OLAT )
                      NJH = findhighcoreindex( VALY,OLAT )

                      NILA = NIH - NIL + 1
                      NJLA = NJH - NJL + 1

                      ROTATE = (ZLAT1.NE.0. .OR. ZLAT2.NE.0.)

                      IF (ROTATE)
     +                CALL D_CROT2( ZLON1,ZLAT1,ZLON2,ZLAT2, ROT )

                      IP3 = 0
                      CALL ZIPIG( IP1,IP2,IP3, DXLA,DYLA,
     +                            NILA,NJLA,OLON,OLAT,
     +                            ROT,ROTATE )

                      IG1 = IP1 
                      IG2 = IP2
                      IG3 = IP3
                      IG4 = 0

                  ELSE

***                    GRID EXPANSION.

                      DYLA  = VALY(  2 )-VALY(   1  )
                      DYLA2 = VALY(ILAT)-VALY(ILAT-1)

                      DXLA  = VALX( 2 )-VALX(  1  )
                      DXLA2 = VALX(ILG)-VALX(ILG-1)

***                    TRANSFER OLD VALUES TO NEW POSITIONS.

                      DO  I=ILG,1,-1
                          VALX(I+I1-1) = VALX(I)
                      END DO
                      DO  J=ILAT,1,-1
                          VALY(J+J1-1) = VALY(J)
                      END DO

***                    EXTEND EASTWARD AND WESTWARD.

                      DO  I=I1-1,1,-1
                          VALX(I)= VALX(I+1)-DXLA
                      END DO
                      DO  I=I1+ILG,OLON
                          VALX(I)= VALX(I-1)+DXLA2
                      END DO

***                    EXTEND SOUTHWARD AND NORTHWARD.

                      DO  J=J1-1,1,-1
                          VALY(J)= VALY(J+1)-DYLA
                      END DO
                      DO  J=J1+ILAT,OLAT
                          VALY(J)= VALY(J-1)+DYLA2
                      END DO

                  END IF

***                WE NOW SUPPOSE THAT THE IG1,IG2 AND IG3 GRID
***                ATTRIBUTES THAT ARE SHARED BY THE DATA RECORDS
***                AND THE REFERENCE DESCRIPTORS HAVE NOT BEEN
***                CHANGED BY THIS OPERATION (EVEN THOUGH
***                THEY MAY WELL HAVE BEEN).

                  CALL PUTZREF( VALX,VALY, 'Z',
     +                          ZTYP,ZIG1,ZIG2,ZIG3,ZIG4,
     +                          IG1,IG2,IG3,OLON,OLAT )

              ELSE

***                GAUSSIAN, A- OR B-GRID OUTPUT ?

                  LATH = OLAT / 2 
                  IF (IHEM.NE.0) LATH = OLAT

***                CHECK FOR A POSSIBLE POINT AT THE POLE.

                  DIST = ABS( VALY(2)-VALY(1) )
                  DIST = (90.-VALY(1))/DIST

                  IF (ABS( DIST-NINT( DIST ) ) .LT. 0.001)     THEN

                      OGRTYP = 'B'

                      IF (IHEM.EQ.1)                           THEN
                          DYLA = PIS2/(OLAT-1)
                          RADL(1) = 0.0
                      ELSE IF (IHEM.EQ.2)                      THEN
                          DYLA = PIS2/(OLAT-1)
                          RADL(1) = -PIS2
                      ELSE
                          DYLA = 2.*PIS2/(OLAT-1)
                          RADL(1) = -PIS2
                      END IF

                      DO  J=2,OLAT
                          RADL(J) = RADL(J-1)+DYLA
                      END DO

                  ELSE

***                    CHECK FOR A POSSIBLE POINT PLACED
***                    HALF A DYLA FROM THE POLE.

                      DIST = DIST-INT( DIST )-0.5

                      IF (ABS( DIST ) .LT. 0.001)              THEN

                          OGRTYP = 'A'

                          DYLA = PIS2/LATH
                          IF (IHEM.EQ.1)                       THEN
                              RADL(1) = 0.5*DYLA
                          ELSE
                              RADL(1) = 0.5*DYLA-PIS2
                          END IF
                          DO  J=2,OLAT
                              RADL(J) = RADL(J-1)+DYLA
                          END DO

                      ELSE

                          OGRTYP = 'G'
                          CALL GAUSSG( LATH, SL,WL,CL,RADL,WOSSL ) 
                          CALL TRIGL2( LATH, SL,WL,CL,RADL,WOSSL,IHEM )

                      END IF

                  END IF

                  IF (MOD(OLON,2).EQ.0)                        THEN
                      DXLA = 360./OLON
                  ELSE
                      DXLA = 360/(OLON-1)
                  END IF

***                FIND MEAN DIFFERENCE BETWEEN THE INPUT Z-GRID
***                COORDINATES AND THOSE OF THE CORRESPONDING
***                KNOWN SUB-GRID. START WITH LONGITUDES.

                  POS  = DBLE( I1-1 )*DXLA - (180.-PJC)
                  IF (VALX(1).LT.0.0) POS = POS-360.

                  DIST = ABS( VALX(1)-POS )

                  DO  I=2,ILG
                      POS = POS+DXLA
                      IF (POS    .GE.360.0) POS  = POS -360.
                      DIST = DIST + ABS( VALX(I)-POS )
                  END DO

***                CONTINUE WITH LATITUDES, AT THE SAME TIME CHECKING
***                FOR DIFFERENT NORTH-SOUTH DATA ORIENTATIONS.

                  IF (VALY(ILAT).GT.VALY(1) .OR. IG4.EQ.1)     THEN
                      DO  J=1,ILAT
                          POS  = PICONV * RADL(J+J1-1)
                          DIST = DIST + ABS( VALY(J)-POS )
                      END DO
                  ELSE
                      DO  J=1,ILAT
                          POS  = PICONV * RADL(OLAT-(J+J1)+2)
                          DIST = DIST + ABS( VALY(J)-POS )
                      END DO
                  END IF

                  DIST = DIST / (ILG+ILAT)

                  IF (DIST .LT. 0.001)                         THEN

***                    OUTPUT TYPE IS RECOGNIZED.

                      OKIND = 'GRID'

                      IG1 = IHEM
                      IG2 = 0
                      IG3 = 0
                      IG4 = 0

                      IF (VALY(ILAT).LT.VALY(1))
     +                IG2 = 1

                  ELSE

                      OGRTYP = GRTYP

***                    OUTPUT IS YET ANOTHER Z-GRID. RE-DEFINE
***                    AN APPROPRIATE SET OF Z-DESCRIPTORS.

                      DYLA  = VALY(  2 )-VALY(   1  )
                      DYLA2 = VALY(ILAT)-VALY(ILAT-1)

                      DXLA  = VALX( 2 )-VALX(  1  )
                      DXLA2 = VALX(ILG)-VALX(ILG-1)

***                    TRANSFER OLD VALUES TO NEW POSITIONS.

                      DO  I=ILG,1,-1
                          VALX(I+I1-1) = VALX(I)
                      END DO
                      DO  J=ILAT,1,-1
                          VALY(J+J1-1) = VALY(J)
                      END DO

***                    EXTEND EASTWARD AND WESTWARD.

                      DO  I=I1-1,1,-1
                          VALX(I)= VALX(I+1)-DXLA
                      END DO
                      DO  I=I1+ILG,OLON
                          VALX(I)= VALX(I-1)+DXLA2
                      END DO

***                    EXTEND SOUTHWARD AND NORTHWARD.

                      DO  J=J1-1,1,-1
                          VALY(I)= VALY(J+1)-DYLA
                      END DO
                      DO  J=J1+ILAT,OLAT
                          VALX(J)= VALY(J-1)+DYLA2
                      END DO

***                    FINALLY, SAVE VALX AND VALY.

                      CALL PUTZREF( VALX,VALY, 'Z',
     +                              ZTYP,ZIG1,ZIG2,ZIG3,ZIG4,
     +                              IG1,IG2,IG3,OLON,OLAT )

                  END IF

              END IF

          END IF

      END IF
              
***    CHECK EXTRA GRID DESCRIPTORS (IF AVAILABLE).
  
      IF (FLIP.AND.LOCAL .AND.
     +   (GRTYP.EQ.'Z' .AND. OKIND.NE.'GRID'))                 THEN

          WRITE(6,6006)
          CALL                                     XIT(' Windowf',-6 )

      END IF

***    READ-IN GRIDS.
  
  200 CALL GETSET2( 1, G, LEV,NLEV1, IBUF,MAXW,OK )
  
          IF (.NOT.OK)                                         THEN
              DEALLOCATE( IBUF,G,DAT, STAT=IER )
              IF (MAXW.EQ.0) GOTO 050
              WRITE(6,6000) NR
              IF (NR.EQ.0) GOTO 9002
              CALL                                 XIT(' Windowf', 0 )
          END IF
  
          WRITE(KIND,4) IBUF(1)
          IF (KIND.EQ.'LABL' .OR. KIND.EQ.'CHAR') GOTO 200

          IF (NR.EQ.0) CALL PRTLAB2(' IBUF  IN =',IBUF )
  
          IF (IBUF(5).NE. ILG     .OR.
     +        IBUF(6).NE. ILAT    .OR.
     +        IBUF(1).NE. JBUF(1) )                            THEN
              CALL                                 XIT(' Windowf',-3 )
          ELSE IF (NLEV1.GT.NLEV )                             THEN
              CALL                                 XIT(' Windowf',-3 )
          END IF

          IF (KIND.EQ.'ZONL') NLEV1 = 1

          IF (TYPE.EQ.0)                                       THEN
  
*=====================================================================
***            EXTRACT WINDOW.
***            =======
  
              WINDO = 1

              DO L=1,NLEV1
              DO 1000 J=LAT1,LAT2
  
                  FULLG = ( (L-1)*LAT + (J-1) ) * LON

                  IF (.NOT. FLIP)                              THEN
                      FULLG = FULLG+LON1
                      IF (CMPL)                                THEN
                          DO  I=LON1,LON2
                              CAT(1,WINDO) = C(1,FULLG)
                              CAT(2,WINDO) = C(2,FULLG)
                              FULLG        = FULLG+1
                              WINDO        = WINDO+1
                          END DO
                      ELSE
                          DO  I=LON1,LON2
                              DAT(WINDO) = G(FULLG)
                              FULLG      = FULLG+1
                              WINDO      = WINDO+1
                          END DO
                      END IF
                  ELSE
                      FULLG = FULLG+LON2
                      IF (CMPL)                                THEN
                          DO  I=LON2,LON-REPL
                              CAT(1,WINDO) = C(1,FULLG)
                              CAT(2,WINDO) = C(2,FULLG)
                              FULLG        = FULLG+1
                              WINDO        = WINDO+1
                          END DO
                          FULLG = FULLG-(LON-REPL)
                          DO  I=1,LON1
                              CAT(1,WINDO) = C(1,FULLG)
                              CAT(2,WINDO) = C(2,FULLG)
                              FULLG        = FULLG+1
                              WINDO        = WINDO+1
                          END DO
                      ELSE
                          DO  I=LON2,LON-REPL
                              DAT(WINDO) = G(FULLG)
                              FULLG      = FULLG+1
                              WINDO      = WINDO+1
                          END DO
                          FULLG = FULLG-(LON-REPL)
                          DO  I=1,LON1
                              DAT(WINDO) = G(FULLG)
                              FULLG      = FULLG+1
                              WINDO      = WINDO+1
                          END DO
                      END IF
                  END IF
  
 1000         CONTINUE
              END DO
  
          ELSE
  
*=====================================================================
***            EXPAND WINDOW.
***            ======
  
              WINDO = 1

              DO L=1,NLEV1
              DO 2000 J=LAT1,LAT2
  
                  FULLG = ( (L-1)*LAT + (J-1) ) * LON

                  IF (.NOT. FLIP)                              THEN
                      FULLG = FULLG+LON1
                      IF (CMPL)                                THEN
                          DO  I=LON1,LON2
                              CAT(1,FULLG) = C(1,WINDO)
                              CAT(2,FULLG) = C(2,WINDO)
                              FULLG        = FULLG+1
                              WINDO        = WINDO+1
                          END DO
                      ELSE
                          DO  I=LON1,LON2
                              DAT(FULLG) = G(WINDO)
                              FULLG      = FULLG+1
                              WINDO      = WINDO+1
                          END DO
                      END IF
                  ELSE
                      FULLG = FULLG+LON2
                      IF (CMPL)                                THEN
                          DO  I=LON2,LON
                              CAT(1,FULLG) = C(1,WINDO)
                              CAT(2,FULLG) = C(2,WINDO)
                              FULLG        = FULLG+1
                              WINDO        = WINDO+1
                          END DO
                          DO  I=1,REPL
                              CAT(1,FULLG) = C(1,WINDO)
                              CAT(2,FULLG) = C(2,WINDO)
                              FULLG        = FULLG+1
                          END DO
                          FULLG = FULLG-LON
                          DO  I=1,LON1
                              CAT(1,FULLG) = C(1,WINDO)
                              CAT(2,FULLG) = C(2,WINDO)
                              FULLG        = FULLG+1
                              WINDO        = WINDO+1
                          END DO
                      ELSE
                          DO  I=LON2,LON
                              DAT(FULLG) = G(WINDO)
                              FULLG      = FULLG+1
                              WINDO      = WINDO+1
                          END DO
                          DO  I=1,REPL
                              DAT(FULLG) = G(WINDO)
                              FULLG      = FULLG+1
                          END DO
                          FULLG = FULLG-LON
                          DO  I=1,LON1
                              DAT(FULLG) = G(WINDO)
                              FULLG      = FULLG+1
                              WINDO      = WINDO+1
                          END DO
                      END IF
                  END IF
  
 2000         CONTINUE
              END DO
  
          END IF
  
*=====================================================================
***        SAVE RESULT GRID. 

          READ(OKIND,4) IBUF(1)

          IBUF(5) = OLON
          IF (TYPE.EQ.0) IBUF(5) = OLON-REPL
          IBUF(6) = OLAT
          IBUF(7) = IHEM
          IF (NPG.NE.999)
     +    IBUF(8) = NPG

          IF (PKTYP == 'SQ')                                   THEN

              CALL PUTHIC( OGRTYP,'GRTYP',IBUF )

              CALL PUTHIGH( IG1,'IG1' ,IBUF ) 
              CALL PUTHIGH( IG2,'IG2' ,IBUF ) 
              CALL PUTHIGH( IG3,'IG3' ,IBUF ) 
              CALL PUTHIGH( IG4,'IG4' ,IBUF ) 

          END IF
              
          CALL PUTSET2( 2, DAT, LEV,NLEV1, IBUF,MAXW )
          IF (NR.EQ.0) CALL PRTLAB2(' IBUF OUT =',IBUF )
  
      NR = NR+NLEV1
      GOTO 200
  
***    E.O.F. ON INPUT

 9000 IF (IO.NE.0) WRITE(6,6140) IO
 9001 CALL                                         XIT(' Windowf',-4 )
  
***    PREMATURE E.O.F. ON UNIT 1.
  
 9002 CALL                                         XIT(' Windowf',-5 )
  
*---------------------------------------------------------------------
    4 FORMAT(A4)
    5 FORMAT(BN,I5)
   10 FORMAT(BN,E10.0)

 5000 FORMAT(10X,5I5,E10.0,I5)

 6000 FORMAT(I10,' Records processed.') 
 6002 FORMAT(' Array of size ',2I4,' at position ',2I4,
     +       ' does not fit in array of size ',2I4)
 6006 FORMAT(' I1 cannot be greater than I2 for sub-area arrays...')
 6016 FORMAT(' At X-interval no. ',I4,' found two identical',
     +       ' consecutive longitudes =',F10.4)
 6100 FORMAT(' Window from I1 , J1=',I3,' , ',I3, 
     1                ' to I2 , J2=',I3,' , ',I3) 
 6110 FORMAT(' Window at   I1 , J1=',I3,' , ',I3,' in grid of size',
     1                   ' I2 X J2=',I3,' X ',I3/ 
     2       ' The default value outside of the window is ',E10.3)
 6120 FORMAT(/' Declared output value of IHEM=',I6,' while its '/
     1       ' value in the input file is',I6,'; reassigning.')
 6140 FORMAT(/' Windowf reports I/O error number ',I4,' on unit 5.')
 6150 FORMAT(/' Possible problem with new equator...')
 6200 FORMAT(/' New Z-grid reference xg1,xg2,xg3,xg4=',4F10.4)

      END 
      SUBROUTINE ANGLEP12( ANGLE, LON1,LAT1,LON2,LAT2 )

      IMPLICIT  none

      REAL      ANGLE, LON1,LAT1,LON2,LAT2

***    CALCUL DE L'ANGLE ENTRE DEUX POINT SUR LA SPHERE UNITE.
***    CES DEUX POINTS SONT DEFINIS PAR LEURS COORDONNEES DANS
***    LE SYSTEME SPHERIQUE.

      REAL*8    PIS2,PICONV
      REAL*8    LON18,LAT18,LON28,LAT28
      REAL*8    A1,A2,A3,B1,B2,B3,C1,C2,C3
*---------------------------------------------------------------------

      PIS2   = ASIN(1.D0)
      PICONV = PIS2 / 90.

      LON18 = LON1*PICONV
      LAT18 = LAT1*PICONV
      LON28 = LON2*PICONV
      LAT28 = LAT2*PICONV

***    CONVERSION EN COORDONNEES RECTANGULAIRES.

      A1 = COS( LAT18 ) * COS( LON18 )
      A2 = COS( LAT18 ) * SIN( LON18 )
      A3 = SIN( LAT18 )

      B1 = COS( LAT28 ) * COS( LON28 )
      B2 = COS( LAT28 ) * SIN( LON28 )
      B3 = SIN( LAT28 )

***    C = A x B = | A | | B | SIN( ANGLE ) U = SIN( ANGLE ) U.

      C1 = A2 * B3 - A3 * B2
      C2 = A3 * B1 - A1 * B3
      C3 = A1 * B2 - A2 * B1

***    DONC, ANGLE = ARC SIN( | C | ) = ARC SIN( SIN (ANGLE ) ).

      ANGLE = ASIN( SQRT( C1*C1 + C2*C2 + C3*C3 ) ) / PICONV

      RETURN

*---------------------------------------------------------------------
      END
#     endif
